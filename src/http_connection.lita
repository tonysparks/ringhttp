import "std/net"
import "std/array"
import "std/string/builder"
import "std/thread"
import "std/mem"
import "std/io"
import "std/libc"

import "http_request"
import "http_response"
import "http_header"
import "http_common"
import "http_file"


public const READ_BUFFER_SIZE = 16 * KiB as (i32)
public const WRITE_BUFFER_SIZE = 8 * KiB as (i32)

public struct HttpConnection {
    id: u32
    socket: Socket
    writeBuffer: StringBuilder
    readBuffer: StringBuilder

    disableKeepAlive: bool
}

public func (this: *HttpConnection) init(allocator: *const Allocator) {
    this.writeBuffer.init(WRITE_BUFFER_SIZE, allocator)
    this.readBuffer.init(READ_BUFFER_SIZE, allocator)
}


public func (this: *HttpConnection) free() {
    this.writeBuffer.free()
    this.readBuffer.free()
    this.socket.close()
}

public func (this: *HttpConnection) reset() {
    //this.writeBuffer.init(WRITE_BUFFER_SIZE, allocator)
    //this.readBuffer.init(READ_BUFFER_SIZE, allocator)
    this.writeBuffer.clear()
    this.readBuffer.clear()
    // this.socket.socket = 0
}

public func (this: *HttpConnection) close() {
    this.socket.close()
}


public func (this: *HttpConnection) handle() : i32 {
    return this.socket.socket
}

public func (this: *HttpConnection) isConnected() : bool {
    return this.socket.socket > 0
}


public func (this: *HttpConnection) bufferContents(response: *HttpResponse) {
    if(response.status > 512) {
        response.status = 500;
    }

    this.writeBuffer.clear()

    // Status Line
    this.writeBuffer.append("HTTP/1.1 %d %s\r\n",
        response.status, STATUS_CODES[response.status]
    )

    // Headers
    for(var i = 0; i < response.numberOfHeaders; i += 1) {
        var header = response.headers[i]
        this.writeBuffer.append("%.*s: %.*s\r\n",
            header.name.length, header.name.buffer,
            header.values.length, header.values.buffer
        )
    }

    var contentLength = 0_usize
    switch(response.type) {
        case ResponseType.NONE: break;
        case ResponseType.BODY: contentLength = response.body.length; break;
        case ResponseType.FILE: contentLength = response.fileSize; break;
        default: break;
    }

    this.writeBuffer.append("Content-Length: %zu\r\n", contentLength)

    // Blank Line
    this.writeBuffer.append("\r\n")

    // Body (if applicable)
    if(response.type == ResponseType.BODY) {
        this.writeBuffer.append("%.*s",
            response.body.length, response.body.buffer
        )
    }
}
