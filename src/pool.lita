import "std/array"
import "std/bucket_list"
import "std/mem"

public trait Initializer<T> {
    allocx: func(*T) : void
}

public struct Pool<T> {
    pool: BucketList<T>
    freeList: Array<i32>

    growBySize: i32
    initializer: Initializer<T>
}

public func (this: *Pool<T>) init<T>(
    initialSize: i32,
    growBySize: i32,
    initializer: Initializer<T>,
    allocator: *const Allocator
) {
    this.growBySize = growBySize
    this.initializer = initializer

    this.pool.init(initialSize, allocator)
    this.freeList.init(initialSize, allocator)
    this.grow<T>(0, initialSize)
}

public func (this: *Pool<T>) free<T>() {
    this.pool.free()
    this.freeList.free()
}

func (this: *Pool<T>) grow<T>(oldSize: i32, newSize: i32) {
    for(var i = oldSize; i < newSize; i+=1) {
        //this.pool.length += 1

        var item: T;
        this.pool.add(item)

        var itemPtr = this.pool.lastPtr()
        memset(itemPtr, 0, sizeof(:T))

        this.initializer.allocx<T>(itemPtr)
        this.freeList.add(i)
    }
}

public func (this: *Pool<T>) alloc<T>() : i32 {
    if(this.freeList.empty()) {
        var oldSize = this.freeList.capacity
        var newSize = oldSize + this.growBySize

        //this.pool.reserve(newSize)
        this.freeList.reserve(newSize)
        this.grow<T>(oldSize, newSize)
    }

    assert(!this.freeList.empty())
    return this.freeList.pop()
}

public func (this: *Pool<T>) get<T>(index: i32) : *T {
    if(index < 0 || index >= this.freeList.capacity) {
        return null;
    }

    return this.pool.getPtr(index)
}

public func (this: *Pool<T>) dealloc<T>(index: i32) {
    if(index < 0 || index >= this.freeList.capacity) {
        return;
    }

    this.freeList.push(index)
}
