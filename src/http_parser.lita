import "std/string"
import "std/string/builder"
import "std/string/buffer"
import "std/array"
import "std/mem"
import "std/libc"
import "std/assert"
import "std/json"

import "http_header"
import "http_request"
import "http_common"
import "http_encoding"
import "log"

@asStr
public enum ParseStatus {
    OK,
    ERROR_INVALID_REQUEST_LINE,
    ERROR_INVALID_HEADERS_SECTION,

    ERROR_INVALID_TEMPLATE_NAME_START,
    ERROR_INVALID_TEMPLATE_NAME_END,

    // Error with multi-part
    ERROR_INVALID_MULTIPART_SECTION,
    ERROR_INVALID_MULTIPART_BOUNDARY,
    ERROR_INVALID_MULTIPART_HEADER,
}

public struct HttpParser {
    allocator: *const Allocator
    request: HttpRequest
}

public func (this: *HttpParser) init(allocator: *const Allocator) {
    this.allocator = allocator
}

public func (this: *HttpParser) parse(input: String, result: *HttpRequest) :  ParseStatus {
    var index = input.indexOf("\r\n", 2)
    if(index < 0) {
        return ParseStatus.ERROR_INVALID_REQUEST_LINE
    }

    // The Request Line (Method Path Http/Version)
    var requestLine = input.substring(0, index)

    var methodIndex = requestLine.indexOf(" ", 1)
    if(methodIndex < 0) {
        return ParseStatus.ERROR_INVALID_REQUEST_LINE
    }

    var pathIndex = requestLine.indexOfAt(" ", 1, methodIndex + 1)
    if(pathIndex < 0) {
        return ParseStatus.ERROR_INVALID_REQUEST_LINE
    }

    var method = requestLine.substring(0, methodIndex)
    result.method = ToHttpMethod(&method)
    result.path = requestLine.substring(methodIndex + 1, pathIndex)
    var queryIndex = result.path.indexOf("?")
    if(queryIndex >= 0) {
        result.query = result.path.substring(queryIndex + 1)
        result.path = result.path.substring(0, queryIndex)
    }

    result.version = requestLine.substring(pathIndex + 1, index)

    var headerInput = input.substring(index + 2)
    var parseResult = this.parseHeaders(&headerInput, result)
    if(parseResult != ParseStatus.OK) {
        return parseResult
    }

    return ParseStatus.OK
}

public func (this: *HttpParser) parseBody(input: String, result: *HttpRequest): ParseStatus {
    var parseResult = this.parseBodyInternal(input, &result.body)
    if(parseResult != ParseStatus.OK) {
        return parseResult
    }
    return ParseStatus.OK
}

func ToHttpMethod(method: *String) : HttpMethod {
    switch(method.length) {
        case 3: {
            // GET
            if(method.equals("GET", method.length)) {
                return HttpMethod.GET
            }
            // PUT
            else if(method.equals("PUT", method.length)) {
                return HttpMethod.PUT
            }
            break;
        }
        case 4: {
            // HEAD
            if(method.equals("HEAD", method.length)) {
                return HttpMethod.HEAD
            }
            // POST
            else if(method.equals("POST", method.length)) {
                return HttpMethod.POST
            }
            break;
        }
        case 5: {
            // TRACE
            if(method.equals("TRACE", method.length)) {
                return HttpMethod.TRACE
            }
            // PATCH
            else if(method.equals("PATCH", method.length)) {
                return HttpMethod.PATCH
            }
            break;
        }
        case 6: {
            // DELETE
            if(method.equals("DELETE", method.length)) {
                return HttpMethod.DELETE
            }
            break;
        }
        case 7: {
            // OPTIONS
            if(method.equals("OPTIONS", method.length)) {
                return HttpMethod.OPTIONS
            }
            // CONNECT
            else if(method.equals("CONNECT", method.length)) {
                return HttpMethod.CONNECT
            }
            break;
        }
        default: {
            break;
        }
    }

    return HttpMethod.INVALID

}

func (this: *HttpParser) parseHeaders(input: *String, result: *HttpRequest) : ParseStatus {
    // TODO: Performance, don't scan input twice
    var rawHeadersIndex = input.indexOf("\r\n\r\n", 4)
    if(rawHeadersIndex < 0) {
        return ParseStatus.ERROR_INVALID_HEADERS_SECTION
    }

    // there are no headers
    if(rawHeadersIndex < 1) {
        return ParseStatus.OK
    }

    defer *input = input.substring(rawHeadersIndex + 2)

    rawHeadersIndex += 2

    result.headers.init(16, this.allocator)

    var rawHeaders = input.substring(0, rawHeadersIndex)
    var current = 0
    while(current < rawHeaders.length) {
        var headerIndex = rawHeaders.indexOfAt("\r\n", 2, current)
        if(headerIndex < 0) {
            return ParseStatus.ERROR_INVALID_HEADERS_SECTION
        }

        var nameStartIndex = -1
        var nameEndIndex = -1

        var valueStartIndex = -1

        var i = current
        while(i < headerIndex) {
            defer i+=1

            var c = rawHeaders.buffer[i]

            if(isspace(c)) {
                continue;
            }

            if(nameStartIndex < 0) {
                nameStartIndex = i
            }

            if(nameEndIndex > -1 && valueStartIndex < 0) {
                valueStartIndex = i
            }

            if(c == ':' && nameEndIndex < 0) {
                nameEndIndex = i
            }
        }

        var name = rawHeaders.substring(nameStartIndex, nameEndIndex)
        var value = rawHeaders.substring(valueStartIndex, headerIndex)

        var header = HttpHeader{
            .name = name,
            .values = value
        }
        this.checkHeader(&header, result)

        result.headers.add(header)
        current = headerIndex + 2
    }

    return ParseStatus.OK
}

func (this: *HttpParser) parseHeader(input: *String, result: *HttpRequest) : ParseStatus {
    // TODO: Performance, don't scan input twice
    var rawHeadersIndex = input.indexOf("\r\n\r\n", 4)
    if(rawHeadersIndex < 0) {
        return ParseStatus.ERROR_INVALID_HEADERS_SECTION
    }

    // there are no headers
    if(rawHeadersIndex < 1) {
        return ParseStatus.OK
    }

    defer *input = input.substring(rawHeadersIndex + 2)

    rawHeadersIndex += 2

    result.headers.init(16, this.allocator)

    var rawHeaders = input.substring(0, rawHeadersIndex)
    var current = 0
    while(current < rawHeaders.length) {
        var headerIndex = rawHeaders.indexOfAt("\r\n", 2, current)
        if(headerIndex < 0) {
            return ParseStatus.ERROR_INVALID_HEADERS_SECTION
        }

        var nameStartIndex = -1
        var nameEndIndex = -1

        var valueStartIndex = -1

        var i = current
        while(i < headerIndex) {
            defer i+=1

            var c = rawHeaders.buffer[i]

            if(isspace(c)) {
                continue;
            }

            if(nameStartIndex < 0) {
                nameStartIndex = i
            }

            if(nameEndIndex > -1 && valueStartIndex < 0) {
                valueStartIndex = i
            }

            if(c == ':' && nameEndIndex < 0) {
                nameEndIndex = i
            }
        }

        var name = rawHeaders.substring(nameStartIndex, nameEndIndex)
        var value = rawHeaders.substring(valueStartIndex, headerIndex)

        var header = HttpHeader{
            .name = name,
            .values = value
        }
        this.checkHeader(&header, result)

        result.headers.add(header)
        current = headerIndex + 2
    }

    return ParseStatus.OK
}


func (this: *HttpParser) checkHeader(header: *HttpHeader, result: *HttpRequest) {

    // TODO: Optimize case insensitivity
    if (header.name.equalsIgnoreCase("connection") && header.values.contains("close")) {
        result.flags |= HttpFlags.DISABLE_KEEP_ALIVE
    }
    else if (header.name.equalsIgnoreCase("content-length")) {
        result.bodyLength = strtol(header.values.buffer, null, 10) as (i32)
    }
    else {
        this.checkHeaderBody(header, &result.body)
    }
}

func (this: *HttpParser) checkHeaderBody(header: *HttpHeader, body: *Body) {
    if (header.name.equalsIgnoreCase("content-type")) {
        if(header.values.equals("application/x-www-form-urlencoded")) {
            body.bodyType = BodyType.FORM_URLENCODED
        }
        else if(header.values.equals("application/json")) {
            body.bodyType = BodyType.JSON
        }
        else if(header.values.startsWith("multipart/form-data")) {
            body.bodyType = BodyType.MULTIPART_FORMDATA
            var boundaryIndex = header.values.endIndexOf("boundary=")
            if(boundaryIndex < 0) {
                return;
            }

            body.multipart.boundary = header.values.substring(boundaryIndex)
        }
    }
}


internal func (this: *HttpParser) parseBodyInternal(input: String, body: *Body) : ParseStatus {
    switch(body.bodyType) {
        case BodyType.FORM_URLENCODED: {
            // Should we error if not POST, PUT, PATCH, OPTIONS, DELETE?

            body.formParams = ArrayInit<FormParam>(16, this.allocator)
            var currentParam = FormParam{}

            var nameIndex = 0
            var nameEndIndex = -1
            var valueIndex = 0
            var valueEndIndex = -1

            for(var i = 0; i < input.length; i += 1) {
                var c = input.buffer[i]
                if(c == '=') {
                    nameEndIndex = i

                    var sb = StringBuilderInit((nameEndIndex - nameIndex) * 3, this.allocator)
                    FormUrlDecode(input.substring(nameIndex, nameEndIndex), sb)
                    currentParam.name = sb.asString()

                    valueIndex = i + 1
                    valueEndIndex = i + 1

                    nameIndex = -1
                    nameEndIndex = -1
                    continue
                }
                else if(c == '&') {
                    valueEndIndex = i

                    var sb = StringBuilderInit((valueEndIndex - valueIndex) * 3, this.allocator)
                    FormUrlDecode(input.substring(valueIndex, valueEndIndex), sb)
                    currentParam.value = sb.asString()

                    body.formParams.add(currentParam)

                    nameIndex = i + 1
                    nameEndIndex = i + 1

                    valueIndex = -1
                    valueEndIndex = -1
                    continue
                }

                if(valueIndex > 0) {
                    valueEndIndex += 1
                }
            }

            if (valueIndex > 0) {
                var sb = StringBuilderInit((valueEndIndex - valueIndex) * 3, this.allocator)
                FormUrlDecode(input.substring(valueIndex, valueEndIndex), sb)
                currentParam.value = sb.asString()

                body.formParams.add(currentParam)
            }
            break
        }
        case BodyType.JSON: {
            var jsonParser = JsonParserInit(this.allocator)

            // TODO: fix horrible duplicate copy
            var sb = StringBuilderInit(input.length, this.allocator)
            input.copyTo(sb.buffer, input.length)

            body.json = jsonParser.parseJson(sb.buffer)

            // TODO: Error handling of bad json
            if (!body.json && input.length > 0) {
                body.bodyType = BodyType.MALFORMED_INPUT
                body.body = input
            }
            break
        }
        case BodyType.MULTIPART_FORMDATA: {
            return this.parseMultipart(input, &body.multipart)
        }
        default: {
            // TODO: More body types
            body.body = input
        }
    }

    return ParseStatus.OK
}

internal func (this: *HttpParser) parseMultipart(input: *String, multipart: *MultiPart) : ParseStatus {
    multipart.parts.init(6, this.allocator)

    var boundary = multipart.boundary
    var index = -1
    var status = ParseStatus.OK

    while(true) {
        if(input.empty()) {
            break
        }

        // ensure start boundary
        status = this.parseMultipartBoundary(input, boundary)
        if(status != ParseStatus.OK) return status;

        // exit if --boundary--
        {
            if(input.startsWith("--", 2)) {
                break
            }
        }

        var part = Part{}
        part.bodyType = BodyType.UNKNOWN
        part.body.buffer = input.buffer;

        // parse headers
        {
            status = this.parseMultipartHeaders(input, &part)
            if(status != ParseStatus.OK) return status
        }

        // parse body
        {
            status = this.parseMultipartBody(input, &part, boundary)
            if(status != ParseStatus.OK) return status
        }

        multipart.parts.add(part)
    }

    return ParseStatus.OK
}

internal func (this: *HttpParser) parseMultipartBoundary(input: *String, boundary: String) : ParseStatus {
    if(!input.startsWith("--", 2)) {
        return ParseStatus.ERROR_INVALID_MULTIPART_BOUNDARY
    }

    *input = input.substring(2)

    var index = input.endIndexOf(boundary.buffer, boundary.length)
    if(index < 0) {
        return ParseStatus.ERROR_INVALID_MULTIPART_BOUNDARY
    }

    *input = input.substring(index)

    if(input.startsWith("\r\n", 2)) {
       *input = input.substring(2)
    }

    return ParseStatus.OK
}

internal func (this: *HttpParser) parseMultipartHeaders(input: *String, part: *Part) : ParseStatus {
    part.headers.init(4, this.allocator)

    var it = input.split("\r\n", 2)
    while(it.hasNext()) {
        var rawHeader = it.next()

        if(rawHeader.empty()) {
            *input = it.remaining()
            break
        }

        var nameValue = rawHeader.split(":", 1)

        if(!nameValue.hasNext()) {
            return ParseStatus.ERROR_INVALID_MULTIPART_HEADER
        }
        var name = nameValue.next()

        if(!nameValue.hasNext()) {
            return ParseStatus.ERROR_INVALID_MULTIPART_HEADER
        }
        var value = nameValue.next()

        var header = HttpHeader{
            .name = name,
            .values = value,
        }
        this.checkHeaderBody(&header, &part.body)

        part.headers.add(header)
    }

    return ParseStatus.OK
}

internal func (this: *HttpParser) parseMultipartBody(input: *String, part: *Part, boundary: String) : ParseStatus {
    var it = input.split(boundary.buffer, boundary.length)
    var formData = &part.formData

    var disposition = part.getHeaderValue(StringInit("content-disposition"))
    if(disposition.contains("form-data")) {
        part.bodyType = BodyType.FORMDATA

        // name
        {
            var index = disposition.endIndexOf(" name=")
            if(index > -1) {
                var endIndex = disposition.indexOfAt(";", 1, index)
                if(endIndex < 0) {
                    endIndex = disposition.length
                }

                formData.name = disposition.substring(index, endIndex)
                if(formData.name.startsWith("\"") && formData.name.endsWith("\"")) {
                    formData.name.buffer += 1
                    formData.name.length -= 2
                }
            }
        }

        // filename
        {
            var index = disposition.endIndexOf("filename=")
            if(index > -1) {
                var endIndex = disposition.indexOfAt(";", 1, index)
                if(endIndex < 0) {
                    endIndex = disposition.length
                }

                formData.filename = disposition.substring(index, endIndex)
                // TODO: Allow for encoded characters
                if(formData.filename.startsWith("\"") && formData.filename.endsWith("\"")) {
                    formData.filename.buffer += 1
                    formData.filename.length -= 2
                }
            }
        }
    }


    // body/value
    if(it.hasNext()) {
        var body = it.next()
        // adjust the \r\n--
        formData.value = body.substring(0, body.length - 4)
    }

    var offset = it.remaining();
    *input = String {
        .buffer = offset.buffer - boundary.length - 2,
        .length = offset.length + boundary.length + 2,
    }

    return ParseStatus.OK
}

//@test
func testParse() {
    var result: HttpRequest;

    var parser = HttpParser{}
    parser.init(defaultAllocator)

    var input = StringInit(
"GET /this/is/path HTTP/1.1\r\nContent-Type: application/x-www-form-urlencoded\r\nOrigin: example.com\r\nAgent:Some other Stuff/And some thingds end.\r\n\r\nname=Anthony+Sparks&address=3265+FORDHAM+CT&phone=414-315-1920"
);

    var ok = parser.parse(input, &result)
    assert(ok == ParseStatus.OK)


    printf("Raw: %.*s\nMethod: '%s' Path: '%.*s' Version: '%.*s'\n",
        input.length, input.buffer,
        HttpMethodAsStr(result.method),
        result.path.length, result.path.buffer,
        result.version.length, result.version.buffer
    )

    for(var i = 0; i < result.headers.size(); i+=1) {
        var header = result.headers.getPtr(i)
        printf("Name: '%.*s' Values: '%.*s'\n",
            header.name.length, header.name.buffer,
            header.values.length, header.values.buffer
        )
    }

    assert(result.bodyType == BodyType.FORM_URLENCODED)
    for(var i = 0; i < result.formParams.size(); i+=1) {
        var form = result.formParams.getPtr(i)
        printf("FormName: '%.*s' Values: '%.*s'\n",
            form.name.length, form.name.buffer,
            form.value.length, form.value.buffer
        )
    }
}



@test
func testParseMultipart() {
    var result: HttpRequest;

    var parser = HttpParser{}
    parser.init(defaultAllocator)

    var input = StringInit(
"POST /upload HTTP/1.1\r\nHost: example.com\r\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW\r\nContent-Length: 356\r\n\r\n------WebKitFormBoundary7MA4YWxkTrZu0gW\r\nContent-Disposition: form-data; name=\"name\"\r\n\r\nJohn Doe\r\n------WebKitFormBoundary7MA4YWxkTrZu0gW\r\nContent-Disposition: form-data; name=\"address\"\r\n\r\n123 Elm Street\r\n------WebKitFormBoundary7MA4YWxkTrZu0gW\r\nContent-Disposition: form-data; name=\"phone\"\r\n\r\n+1234567890\r\n------WebKitFormBoundary7MA4YWxkTrZu0gW\r\nContent-Disposition: form-data; name=\"file\"; filename=\"example.txt\"\r\nContent-Type: text/plain\r\n\r\nThis is the content of the file.\r\n------WebKitFormBoundary7MA4YWxkTrZu0gW--"
);

    var ok = parser.parse(input, &result)
    printf("Status: %s\n", ParseStatusAsStr(ok))
    assert(ok == ParseStatus.OK)


    printf("Raw: %.*s\nMethod: '%s' Path: '%.*s' Version: '%.*s'\n",
        input.length, input.buffer,
        HttpMethodAsStr(result.method),
        result.path.length, result.path.buffer,
        result.version.length, result.version.buffer
    )

    for(var i = 0; i < result.headers.size(); i+=1) {
        var header = result.headers.getPtr(i)
        printf("Name: '%.*s' Values: '%.*s'\n",
            header.name.length, header.name.buffer,
            header.values.length, header.values.buffer
        )
    }

    assert(result.bodyType == BodyType.MULTIPART_FORMDATA)
    printf("boundary: '%.*s'\n", result.multipart.boundary.length, result.multipart.boundary.buffer)
    for(var i = 0; i < result.multipart.parts.size(); i+=1) {
        var part = result.multipart.parts.getPtr(i)
        printf("Part: \n")
        for(var j = 0; j < part.headers.size(); j+=1) {
            var header = part.headers.getPtr(j)
            printf("Header Name: '%.*s' Values: '%.*s'\n",
                header.name.length, header.name.buffer,
                header.values.length, header.values.buffer
            )
        }

        printf("Name: '%.*s'\n", part.formData.name.length, part.formData.name.buffer)
        printf("Filename: '%.*s'\n", part.formData.filename.length, part.formData.filename.buffer)
        printf("Value: '%.*s'\n", part.formData.value.length, part.formData.value.buffer)

    }
}
