import "std/string"
import "std/string/builder"
import "std/string/buffer"
import "std/array"
import "std/mem"
import "std/libc"
import "std/assert"

import "http_header"
import "http_request"
import "http_common"
import "http_encoding"

public enum ParseStatus {
    OK,
    ERROR_INVALID_REQUEST_LINE,
    ERROR_INVALID_HEADERS_SECTION,

    ERROR_INVALID_TEMPLATE_NAME_START,
    ERROR_INVALID_TEMPLATE_NAME_END,

    ERROR_INVALID_MULTIPART_SECTION,
}

public struct HttpParser {
    allocator: *const Allocator
    request: HttpRequest
}

public func (this: *HttpParser) init(allocator: *const Allocator) {
    this.allocator = allocator
}

public func (this: *HttpParser) parse(input: String, result: *HttpRequest) :  ParseStatus {
    var index = input.indexOf("\r\n", 2)
    if(index < 0) {
        return ParseStatus.ERROR_INVALID_REQUEST_LINE
    }

    // The Request Line (Method Path Http/Version)
    var requestLine = input.substring(0, index)

    var methodIndex = requestLine.indexOf(" ", 1)
    if(methodIndex < 0) {
        return ParseStatus.ERROR_INVALID_REQUEST_LINE
    }

    var pathIndex = requestLine.indexOfAt(" ", 1, methodIndex + 1)
    if(pathIndex < 0) {
        return ParseStatus.ERROR_INVALID_REQUEST_LINE
    }

    var method = requestLine.substring(0, methodIndex)
    result.method = ToHttpMethod(&method)
    result.path = requestLine.substring(methodIndex + 1, pathIndex)
    result.version = requestLine.substring(pathIndex + 1, index)

    var headerInput = input.substring(index + 2)
    var parseResult = this.parseHeaders(&headerInput, result)
    if(parseResult != ParseStatus.OK) {
        return parseResult
    }

    parseResult = this.parseBody(headerInput, result)
    if(parseResult != ParseStatus.OK) {
        return parseResult
    }

    return ParseStatus.OK
}

func ToHttpMethod(method: *String) : HttpMethod {
    switch(method.length) {
        case 3: {
            // GET
            if(method.equalsIgnoreCase("GET", method.length)) {
                return HttpMethod.GET
            }
            // PUT
            else if(method.equalsIgnoreCase("PUT", method.length)) {
                return HttpMethod.PUT
            }
            break;
        }
        case 4: {
            // HEAD
            if(method.equalsIgnoreCase("HEAD", method.length)) {
                return HttpMethod.HEAD
            }
            // POST
            else if(method.equalsIgnoreCase("POST", method.length)) {
                return HttpMethod.POST
            }
            break;
        }
        case 5: {
            // TRACE
            if(method.equalsIgnoreCase("TRACE", method.length)) {
                return HttpMethod.TRACE
            }
            // PATCH
            else if(method.equalsIgnoreCase("PATCH", method.length)) {
                return HttpMethod.PATCH
            }
            break;
        }
        case 6: {
            // DELETE
            if(method.equalsIgnoreCase("DELETE", method.length)) {
                return HttpMethod.DELETE
            }
            break;
        }
        case 7: {
            // OPTIONS
            if(method.equalsIgnoreCase("OPTIONS", method.length)) {
                return HttpMethod.OPTIONS
            }
            // CONNECT
            else if(method.equalsIgnoreCase("CONNECT", method.length)) {
                return HttpMethod.CONNECT
            }
            break;
        }
        default: {
            break;
        }
    }

    return HttpMethod.INVALID

}

func (this: *HttpParser) parseHeaders(input: *String, result: *HttpRequest) : ParseStatus {
    // TODO: Performance, don't scan input twice
    var rawHeadersIndex = input.indexOf("\r\n\r\n", 4)
    if(rawHeadersIndex < 0) {
        return ParseStatus.ERROR_INVALID_HEADERS_SECTION
    }

    // there are no headers
    if(rawHeadersIndex < 1) {
        return ParseStatus.OK
    }

    defer *input = input.substring(rawHeadersIndex + 2)

    rawHeadersIndex += 2

    result.headers.init(16, this.allocator)

    var rawHeaders = input.substring(0, rawHeadersIndex)
    var current = 0
    while(current < rawHeaders.length) {
        var headerIndex = rawHeaders.indexOfAt("\r\n", 2, current)
        if(headerIndex < 0) {
            return ParseStatus.ERROR_INVALID_HEADERS_SECTION
        }

        var nameStartIndex = -1
        var nameEndIndex = -1

        var valueStartIndex = -1

        var i = current
        while(i < headerIndex) {
            defer i+=1

            var c = rawHeaders.buffer[i]

            if(isspace(c)) {
                continue;
            }

            if(nameStartIndex < 0) {
                nameStartIndex = i
            }

            if(nameEndIndex > -1 && valueStartIndex < 0) {
                valueStartIndex = i
            }

            if(c == ':' && nameEndIndex < 0) {
                nameEndIndex = i
            }
        }

        var name = rawHeaders.substring(nameStartIndex, nameEndIndex)
        var value = rawHeaders.substring(valueStartIndex, headerIndex)

        var header = HttpHeader{
            .name = name,
            .values = value
        }
        this.checkHeader(&header, result)

        result.headers.add(header)
        current = headerIndex + 2
    }

    return ParseStatus.OK
}

func (this: *HttpParser) checkHeader(header: *HttpHeader, result: *HttpRequest) {

    // TODO: Optimize case insensitivity
    if (header.name.equalsIgnoreCase("connection") && header.values.contains("close")) {
        result.flags |= HttpFlags.DISABLE_KEEP_ALIVE
    }

    if (header.name.equalsIgnoreCase("content-type")) {
        if(header.values.equals("application/x-www-form-urlencoded")) {
            result.bodyType = BodyType.FORM_URLENCODED
        }
    }
}

internal func (this: *HttpParser) parseBody(input: String, result: *HttpRequest) : ParseStatus {
    switch(result.bodyType) {
        case BodyType.FORM_URLENCODED: {
            // Should we error if not POST, PUT, PATCH, OPTIONS, DELETE?

            result.formParams = ArrayInit<FormParam>(16, this.allocator)
            var currentParam = FormParam{}

            var nameIndex = 0
            var nameEndIndex = -1
            var valueIndex = 0
            var valueEndIndex = -1

            for(var i = 0; i < input.length; i += 1) {
                var c = input.buffer[i]
                if(c == '=') {
                    nameEndIndex = i

                    var sb = StringBuilderInit((nameEndIndex - nameIndex) * 3, this.allocator)
                    FormUrlDecode(input.substring(nameIndex, nameEndIndex), sb)
                    currentParam.name = sb.asString()

                    valueIndex = i + 1
                    valueEndIndex = i + 1

                    nameIndex = -1
                    nameEndIndex = -1
                    continue
                }
                else if(c == '&') {
                    valueEndIndex = i

                    var sb = StringBuilderInit((valueEndIndex - valueIndex) * 3, this.allocator)
                    FormUrlDecode(input.substring(valueIndex, valueEndIndex), sb)
                    currentParam.value = sb.asString()

                    result.formParams.add(currentParam)

                    nameIndex = i + 1
                    nameEndIndex = i + 1

                    valueIndex = -1
                    valueEndIndex = -1
                    continue
                }

                if(valueIndex > 0) {
                    valueEndIndex += 1
                }
            }

            if (valueIndex > 0) {
                var sb = StringBuilderInit((valueEndIndex - valueIndex) * 3, this.allocator)
                FormUrlDecode(input.substring(valueIndex, valueEndIndex), sb)
                currentParam.value = sb.asString()

                result.formParams.add(currentParam)
            }
            break
        }
        default: {
            // TODO: More body types
        }
    }

    return ParseStatus.OK
}


@test
func testParse() {
    var result: HttpRequest;

    var parser = HttpParser{}
    parser.init(defaultAllocator)

    var input = StringInit(
"GET /this/is/path HTTP/1.1\r\nContent-Type: application/x-www-form-urlencoded\r\nOrigin: example.com\r\nAgent:Some other Stuff/And some thingds end.\r\n\r\nname=Anthony+Sparks&address=3265+FORDHAM+CT&phone=414-315-1920"
);

    var ok = parser.parse(input, &result)
    assert(ok == ParseStatus.OK)


    printf("Raw: %.*s\nMethod: '%s' Path: '%.*s' Version: '%.*s'\n",
        input.length, input.buffer,
        HttpMethodAsStr(result.method),
        result.path.length, result.path.buffer,
        result.version.length, result.version.buffer
    )

    for(var i = 0; i < result.headers.size(); i+=1) {
        var header = result.headers.getPtr(i)
        printf("Name: '%.*s' Values: '%.*s'\n",
            header.name.length, header.name.buffer,
            header.values.length, header.values.buffer
        )
    }

    assert(result.bodyType == BodyType.FORM_URLENCODED)
    for(var i = 0; i < result.formParams.size(); i+=1) {
        var form = result.formParams.getPtr(i)
        printf("FormName: '%.*s' Values: '%.*s'\n",
            form.name.length, form.name.buffer,
            form.value.length, form.value.buffer
        )
    }
}
