import "std/net"
import "std/libc"
import "std/thread"
import "std/mem"
import "std/mem/bucket_allocator"
import "std/mem/thread_safe_allocator"
import "std/string/builder"
import "std/string"
import "std/array"
import "std/io"
import "std/libc/signal"
import "std/atomic"
import "std/assert"

// posix specific
import "std/net/posix_socket"
import "pipe_posix"

import "liburing"

import "http_connection"
import "http_parser"
import "http_common"
import "http_request"
import "http_response"
import "http_header"
import "http_file"
import "http_server"
import "http_router"

import "pool"
import "log"

@foreign
func strerror(errnum: i32) : *const char;

internal struct HttpRingEngine {
    config: using *HttpConfig
    safeAllocator: ThreadSafeAllocator
    serverSocket: Socket

    // IO Uring for socket Accepts
    accept: io_uring

    // workers: Array<WorkerThread>
    requests: Pool<Request>

    distribution: u64

    isRunning: Atomic<bool>
    // submissions: u32

    router: Router

    errorHandler: HttpHandler
    notFoundHandler: HttpHandler
    filterHandlers: Array<HttpFilterHandler>
}

func myerror(str: *const char) {
    perror(str)
    errno = 0
}

// struct WorkerThread {
//     engine: *HttpRingEngine
//     thread: Thread
//     ring: io_uring
// }

@asStr
enum RequestState {
    CONNECTED,
    READ_REQUEST_LINE,
    WRITTEN_HTTP_RESPONSE,
    WRITTEN_HTTP_RESPONSE_MORE,
    WRITTEN_FILE,
}

internal struct Request {
    index: i32
    requests: *Pool<Request>

    clientAddr: sockaddr_in;
    clientAddrLen: socklen_t;

    connection: HttpConnection
    response: HttpResponse
    state: RequestState

    // Allocator for each request on this thread
    requestAllocator: BucketAllocator

    // for file transmission
    pipes: [2]i32

    // file handle if opened
    file: i32

    // SQE requests submissions
    submissions: u32
}

// begining of a HTTP request cycle
func (this: *Request) begin() {
    this.requestAllocator.clear()

    var allocator = &this.requestAllocator.allocator
    this.connection.init(allocator)
    this.response.init(allocator)

    this.submissions = 0

    if(this.pipes[0] > 0) {
        close(this.pipes[0])
    }

    if(this.pipes[1] > 0) {
        close(this.pipes[1])
    }

    if(this.file > 0) {
        close(this.file)
    }
    this.file = 0

    this.pipes[0] = 0
    this.pipes[1] = 0

    this.clientAddrLen = sizeof(this.clientAddr) as (socklen_t);
}

// ending of an HTTP request cycle, with optional force connection close
func (this: *Request) finish(forceClose: bool = false) {
    Info("Finishing Request for socket: %d\n", this.connection.handle())

    this.submissions = 0

    if(this.pipes[0] > 0) {
        close(this.pipes[0])
    }

    if(this.pipes[1] > 0) {
        close(this.pipes[1])
    }

    if(this.file > 0) {
        close(this.file)
    }
    this.file = 0

    //this.connection.reset()
    //this.response.reset()

    if(!this.isKeepAlive() || forceClose) {
        this.connection.close()
        this.requests.dealloc(this.index)
    }
}

func (this: *Request) free() {
    this.finish(.forceClose = true)

    this.connection.free()
    this.response.free()
}

func (this: *Request) isKeepAlive(): bool {
    return !this.connection.disableKeepAlive
}

internal func (this: *HttpRingEngine) init(config: *HttpConfig) {
    this.config = config
    this.distribution = 0_u64

    this.safeAllocator.init(config.allocator)
    this.router.init(config.allocator)
    // this.workers.init(config.maxThreads, config.allocator)
    this.requests.init(1, 1, this, config.allocator)

    this.filterHandlers.init(32, config.allocator)
}

// internal func (this: *HttpRingEngine) free() {
//     this.filterHandlers.free()
//     for(var i = 0; i < this.requests.pool.length; i+=1) {
//         var request = this.requests.pool.getPtr(i)
//         request.free()
//     }
//     this.requests.free()
//     for(var i = 0; i < this.workers.length; i+=1) {
//         var worker = this.workers.getPtr(i)

//     }
// }

// func (this: *HttpRingEngine) setupWorkerThread(worker: *WorkerThread) {
//     if(io_uring_queue_init(this.ioQueueDepth, &worker.ring, 0/*IORING_SETUP_SQPOLL*/) < 0) {
//         myerror("io_uring_queue_init")
//     }
//     Info("Created io_uring context\n")
// }

public func (this: *HttpRingEngine) allocx(request: *Request) {
    request.requestAllocator.init(this.safeAllocator, this.requestBucketSizeInBytes)
}

internal func (this: *HttpRingEngine) addRequestHandler(
    method: HttpMethod,
    path: *const char,
    controller: *HttpController
) : Status {
    if(!this.router.register(method, path, controller)) {
        return Status.ERROR_UNABLE_TO_REGISTER_HANDLER
    }

    return Status.OK
}

internal func (this: *HttpRingEngine) setErrorHandler(errorHandler: HttpHandler) {
    this.errorHandler = errorHandler
}

internal func (this: *HttpRingEngine) setNotFoundHandler(notFoundHandler: HttpHandler) {
    this.notFoundHandler = notFoundHandler
}

internal func (this: *HttpRingEngine) addFilterHandler() {
    // TODO - add in router
}

internal func (this: *HttpRingEngine) listen() : Status {
    this.close()

    // this.distribution = 0_u64
    this.isRunning.init(true)

    // for(var i = 0; i < this.config.maxThreads; i+=1) {
    //     this.workers.add(WorkerThread{
    //         .engine = this,
    //         .thread = Thread{}
    //     })

    //     var worker = this.workers.getPtr(i)
    //     this.setupWorkerThread(worker)
    //     /*var thread = &worker.thread

    //     var status = thread.create(RequestThread, context)
    //     if(status != ThreadStatus.SUCCESS) {
    //         Error("Failed to create thread: %s\n", ThreadStatusAsStr(status))
    //     }*/
    // }

    io_uring_queue_init(this.config.ioQueueDepth, &this.accept, 0/*IORING_SETUP_SQPOLL*/);

    if(!this.serverSocket.create()) {
        return Status.ERROR_UNABLE_TO_CREATE_SERVER_SOCKET
    }

    defer this.serverSocket.close()

    var enableReuse = 1
    this.serverSocket.setSocketOpt(SocketOption.SO_REUSEADDR, &enableReuse, sizeof(:i32))

    if(!FromPort(this.config.port, &this.serverSocket.address)) {
        return Status.ERROR_CREATING_ADDRESS
    }

    if(!this.serverSocket.bind()) {
        return Status.ERROR_SOCKET_BIND
    }

    if(!this.serverSocket.listen()) {
        return Status.ERROR_SOCKET_LISTEN
    }

    var ring = &this.accept

    // prime the pump, dispatch a request for socket accepts
    this.queueAcceptRequest(ring)

    var cqe: *io_uring_cqe = null;

    while(true) {
        var result = io_uring_wait_cqe(ring, &cqe);
        this.handleCompletionRing(ring, cqe, result)

        io_uring_cqe_seen(ring, cqe)

        // if(io_uring_sq_space_left(&this.accept) < this.ioQueueDepth)  {
        //     break;
        // }

        io_uring_submit(ring)
    }

    return Status.OK
}


internal func (this: *HttpRingEngine) close() {
    this.isRunning.set(false)

    // for(var i = 0; i < this.workers.size(); i+=1) {
    //     var worker = this.workers.getPtr(i)

    //     // wait for the thread to complete
    //     worker.thread.join()

    //     // close out the io buffers
    //     io_uring_queue_exit(&worker.ring)
    // }

    this.filterHandlers.free()

    this.serverSocket.close()
    this.safeAllocator.free()

    if(this.accept.ring_fd > 0) {
        io_uring_queue_exit(&this.accept)
    }
}



func (this: *HttpRingEngine) queueAcceptRequest(ring: *io_uring) {
    var index = this.requests.alloc()
    var request = this.requests.get(index)
    assert(request != null)

    request.index = index
    request.requests = &this.requests
    request.state = RequestState.CONNECTED

    request.begin()

    var sqe = io_uring_get_sqe(ring)
    if(!sqe) {
        Error("Error creating SQE for server socket\n")
        goto error;
    }

    io_uring_prep_accept(
        sqe,
        this.serverSocket.handle(),
        (&request.clientAddr) as (*sockaddr),
        &request.clientAddrLen,
        0
    )

    io_uring_sqe_set_data(sqe, request)
    io_uring_submit(ring)

error:
    return;
}

func (this: *HttpRingEngine) queueReadHttpRequest(ring: *io_uring, clientSocket: i32, request: *Request) {
    Info("Reading HTTP request for socket: %d state: %s\n", clientSocket, RequestStateAsStr(request.state))

    request.state = RequestState.READ_REQUEST_LINE

    var connection = &request.connection
    connection.socket.socket = clientSocket

    var sqe = io_uring_get_sqe(ring)
    if(!sqe) {
        Error("Error creating SQE for socket: %d\n", clientSocket)
        goto error;
    }

    // Listen for bytes from the client, store them in
    // our readBuffer, this may take multiple reads to complete
    // the full client socket payload
    io_uring_prep_read(
        sqe,
        clientSocket,
        connection.readBuffer.buffer + connection.readBuffer.length,
        connection.readBuffer.remaining(),
        0
    )

    io_uring_sqe_set_data(sqe, request)
    io_uring_submit(ring)

error:
    return;
}

func (this: *HttpRingEngine) queueWriteHttpResponse(
    ring: *io_uring,
    request: *Request) {

    request.state = RequestState.WRITTEN_HTTP_RESPONSE

    var connection = &request.connection
    var response = &request.response

    connection.bufferContents(response)

    Info("Writing Http Response (%d): \n%.*s\n",
        connection.handle(),
        connection.writeBuffer.length, connection.writeBuffer.buffer)


    var iov = iovec {
        .iov_base = connection.writeBuffer.buffer,
        .iov_len  = connection.writeBuffer.length,
    }

    var msg = msghdr {
        .msg_iov = &iov,
        .msg_iovlen = 1,
    }

    var moreContents = response.type == ResponseType.FILE

    // Send the HTTP response to the client socket
    var sqe = io_uring_get_sqe(ring)
    if(!sqe) {
        Error("Error creating SQE for socket: %d\n", connection.handle())
        goto error;
    }

    io_uring_prep_sendmsg(
        sqe,
        connection.handle(),
        &msg,
        moreContents ? SocketFlags.MSG_MORE : 0
    )

    // If we have more contents, let's link
    // this submission with the next one, so they are delivered
    // in proper order
    if(moreContents) {
        request.state = RequestState.WRITTEN_HTTP_RESPONSE_MORE
        sqe.flags |= IOSQE_IO_LINK
    }

    io_uring_sqe_set_data(sqe, request)

    request.submissions += 1
    io_uring_submit(ring)

    if(moreContents) {
        this.queueWriteHttpFileResponse(ring, request)
    }

error:
    return;
}

func (this: *HttpRingEngine) queueWriteHttpFileResponse(
    ring: *io_uring,
    request: *Request) {

    request.state = RequestState.WRITTEN_FILE

    var response = &request.response
    var connection = &request.connection

    var fileFd = response.fileHandle
    var fileSize = response.fileSize
    var socketFd = connection.handle()


    /*
        Must move the file on disk thru a pipe to client socket:
        File => Pipe => ClientSocket
    */

    if(pipe2(request.pipes, O_CLOEXEC | O_NONBLOCK) < 0) {
        Error("Error creating pipes!")
        goto error;
    }


    // move the file to the pipe
    {
        var sqe = io_uring_get_sqe(ring)
        if(!sqe) {
            Error("Error creating SQE for socket: %d\n", socketFd)
            goto error;
        }

        io_uring_prep_splice(
            sqe,
            response.fileHandle,
            0_i64,
            request.pipes[1],
            -1_i64,
            response.fileSize as (u32),
            0
        )
        sqe.flags |= IOSQE_IO_LINK//|IORING_SQ_NEED_WAKEUP

        io_uring_sqe_set_data(sqe, request)
    }

    // move the pipe to the socket
    {
        var sqe = io_uring_get_sqe(ring)
        if(!sqe) {
            Error("Error creating SQE for socket: %d\n", socketFd)
            goto error;
        }

        io_uring_prep_splice(
            sqe,
            request.pipes[0],
            -1_i64,
            connection.handle(),
            -1_i64,
            response.fileSize as (u32),
            0
        )

        io_uring_sqe_set_data(sqe, request)
    }

    request.submissions += 2
    io_uring_submit(ring)

error:
    return;
}



func (this: *HttpRingEngine) handlePartialHttpRequest(
    ring: *io_uring,
    requestAllocator: *const Allocator,
    request: *Request,
    bytesRead: i32) : Status {

    var connection = &request.connection
    var readBuffer = &connection.readBuffer


    readBuffer.length += bytesRead
    if(readBuffer.remaining() < 1024) {
        readBuffer.reserve(readBuffer.capacity + 1024)
    }

    // check to see if we are exceeding our limit
    if(readBuffer.length >= MAX_REQUEST_LINE_SIZE) {
        Error("Request exceeded max request limit for connection: %d\n", connection.handle())
        // error out - request is too big
        return Status.ERROR_INVALID_REQUEST_PATH_EXCEEDED_LIMIT
    }

    // determine if we read all of the request line and headers
    if(!readBuffer.contains("\r\n\r\n")) {
        Info("Request was a partial read for connection: %d\n", connection.handle())
        return Status.PARTIAL_REQUEST_DISPATCHING_READ
    }

    // we are ready to handle the full request
    return Status.OK
}

func (this: *HttpRingEngine) handleHttpRequest(
    ring: *io_uring,
    requestAllocator: *const Allocator,
    request: *Request) : Status {

    var connection = &request.connection

    var buffer = &connection.readBuffer
    Info("Beging handling HTTP Request for socket: %d: %.*s\n", connection.handle(), buffer.length, buffer.buffer)

    var parser = HttpParser{}
    parser.init(requestAllocator)

    var input = StringInit(buffer.buffer, buffer.length)

    var httpRequest: HttpRequest;
    var ok = parser.parse(input, &httpRequest)
    if(ok != ParseStatus.OK) {
        return Status.ERROR_PARSING_HTTP_REQUEST
    }

    connection.disableKeepAlive = httpRequest.flags & HttpFlags.DISABLE_KEEP_ALIVE

    switch(httpRequest.method) {
        case HttpMethod.GET: {

            // determine if this is a file request
            if(httpRequest.path.startsWith(this.fileServerPath)) {
                var file: File;
                var fileStatus = OpenFile(this.fileServerPath, httpRequest.path, &file)
                if(fileStatus != Status.OK) {
                    return fileStatus
                }

                request.file = file.handle()

                var response = &request.response;
                response.status = 200
                response.type = ResponseType.FILE
                // TODO add mime type info..
                response.fileHandle = file.handle()
                response.fileSize = file.length()

                this.queueWriteHttpResponse(ring, request)
                return Status.OK
            }
            break
        }
        case HttpMethod.POST:
        case HttpMethod.PUT:
        case HttpMethod.PATCH:
        case HttpMethod.OPTIONS:
        case HttpMethod.DELETE: {
            break
        }
    }

    var requestContext = RequestHandlerContext {
        .allocator = requestAllocator,
        .request = &httpRequest,
        .response = &request.response,
        .userData = null,
        .match = null
    }

    var requestMatch: RouteMatch;
    if(!this.router.match(httpRequest.method, httpRequest.path, &requestMatch)) {
        this.server404(&requestContext, Status.ERROR_NO_ROUTE_FOUND)
    }
    else {

        var controller = requestMatch.controller
        Info("Found a match: %.*s\n", requestMatch.template.template.length, requestMatch.template.template.buffer)

        requestContext.userData = controller.userData
        requestContext.match = &requestMatch

        if(controller.callback(&requestContext) != 1) {
            this.serverError(&requestContext, Status.ERROR_CONTROLLER_CALLBACK_ERROR)
        }
    }

    this.queueWriteHttpResponse(ring, request)

    Info("Done handling HTTP Request for socket: %d\n", connection.handle())
    return Status.ERROR_UNSUPPORTED_METHOD
}

func (this: *HttpRingEngine) sendServerError(
    request: *Request,
    status: Status,
    ring: *io_uring
) {
    var httpRequest = HttpRequest{}
    var requestContext = RequestHandlerContext {
        .allocator = &request.requestAllocator.allocator,
        .request = &httpRequest,
        .response = &request.response,
        .userData = null,
        .match = null
    }

    this.serverError(requestContext, status)
    this.queueWriteHttpResponse(ring, request)
}

func (this: *HttpRingEngine) serverError(
    requestContext: *RequestHandlerContext,
    status: Status
) {
    var request = requestContext.request
    var response = requestContext.response

    Error("Internal Error handling request: %s %.*s\n",
        HttpMethodAsStr(request.method),
        request.path.length, request.path.buffer
    )

    response.status = 500

    if (this.errorHandler.__this) {
        this.errorHandler.handle(
            requestContext,
            status
        )
    }
    else {
        // TODO add mime type info..
        response.type = ResponseType.BODY
        response.body.append("Internal Error handling the request.")
    }
}

func (this: *HttpRingEngine) server404(
    requestContext: *RequestHandlerContext,
    status: Status
) {
    var request = requestContext.request
    var response = requestContext.response

    Error("Could not find match for request: %s %.*s\n",
        HttpMethodAsStr(request.method),
        request.path.length, request.path.buffer
    )

    response.status = 404

    if (this.notFoundHandler.__this) {
        this.notFoundHandler.handle(
            requestContext,
            status
        )
    }
    else {
        // TODO add mime type info..
        response.type = ResponseType.BODY
        response.body.append("No route bound.")
    }
}

func signal_handler(signo: i32) {
    Error("caught signal SIGPIPE for %d\n", signo)
}

func (this: *HttpRingEngine) handleCompletionRing(ring: *io_uring, cqe: *io_uring_cqe, result: i32) {

    // Determine if there was an error reading the accept socket request
    if(result < 0 || !cqe) {
        Error("Error reading accept socket socket: %d\n", result)
        return;
    }

    // If the accept socket request completed, but the result contains an error
    if(cqe.res < 0) {
        Error("Error accepting socket.res: %d (%s)\n", cqe.res, strerror(-cqe.res))

        // Force close the connection
        var request = io_uring_cqe_get_data(cqe) as (*Request)
        if(request) {
            Error("Force closing connection: %d due to error\n", request.connection.handle())
            request.finish(.forceClose = true)
        }
        return;
    }

    var request = io_uring_cqe_get_data(cqe) as (*Request)
    assert(request != null)

    var connection = &request.connection
    switch(request.state) {
        // Server just accepted a client connection
        case RequestState.CONNECTED: {
            Info("CONNECTED: socket: %d subs: %d index: %d\n", cqe.res, request.submissions, request.index)

            // queue up another accept
            this.queueAcceptRequest(ring)

            // queue up delegation of handling the http request
            this.queueReadHttpRequest(ring, cqe.res, request)
            break;
        }
        // The connection was established, and we've read
        // the client socket contents for the HTTP request line
        case RequestState.READ_REQUEST_LINE: {
            var bytesRead = cqe.res
            Info("READ_REQUEST_LINE: %d for socket: %d subs: %d\n", bytesRead, connection.handle(), request.submissions)

            // The client has gracefully closed their connection
            if(bytesRead == 0) {
                Info("Client Closed socket: %d\n", connection.handle())
                request.finish(.forceClose = true)
                break;
            }

            var allocator = &request.requestAllocator.allocator

            var status = this.handlePartialHttpRequest(
                ring,
                allocator,
                request,
                bytesRead
            )

            if(status == Status.PARTIAL_REQUEST_DISPATCHING_READ) {
                this.queueReadHttpRequest(ring, connection.handle(), request)
                break
            }

            if(status != Status.OK) {
                this.sendServerError(request, status, ring)
                break
            }

            // queue up delegation of handling the http response
            status = this.handleHttpRequest(
                ring,
                allocator,
                request
            )

            if(status != Status.OK) {
                Error("HTTP Request Bad Status %s with index: %d\n", StatusAsStr(status), request.index)
                this.sendServerError(request, status, ring)
            }
            break
        }

        // The connection request was parsed, we have dispatched
        // an http response to the client socket
        case RequestState.WRITTEN_HTTP_RESPONSE:
        case RequestState.WRITTEN_HTTP_RESPONSE_MORE:
        case RequestState.WRITTEN_FILE: {
            request.submissions -= 1
            Info("%s for socket: %d subs: %d index: %d\n",
                RequestStateAsStr(request.state),
                connection.handle(),
                request.submissions,
                request.index
            )

            if(request.submissions <= 0) {
                request.begin() // ready to begin another HTTP request cycle

                // listen for close socket from client
                this.queueReadHttpRequest(ring, connection.handle(), request)
            }
            break
        }

        default: {
            assert(false)
            break;
        }
    }
}

