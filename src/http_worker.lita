import "std/net"
import "std/libc"
import "std/thread"
import "std/thread/thread_pool"
import "std/mem"
import "std/mem/bucket_allocator"
import "std/mem/linear_allocator"
import "std/mem/thread_safe_allocator"
import "std/string/builder"
import "std/string/buffer"
import "std/string"
import "std/array"
import "std/io"
import "std/libc/signal"
import "std/atomic"
import "std/assert"
import "std/system"
import "std/log"

// posix specific
import "std/net/posix_socket"
import "pipe_posix"

import "liburing"

import "http_connection"
import "http_parser"
import "http_common"
import "http_request"
import "http_response"
import "http_file"
import "http_server"
import "http_router"
import "http_context"
import "http_websocket"
import "http_engine"

internal struct WorkerThread {
    ring: io_uring
    thread: Thread
    index: i32

    server: *HttpServer
    config: *HttpConfig
    sessions: ContextPool
}

internal func (this: *WorkerThread) init(
    server: *HttpServer,
    index: i32
): Status {

    this.server = server
    this.config = server.config
    this.index = index

    this.ring = io_uring{}

    var status = this.sessions.init(this.server)
    if(status != Status.OK) {
        return status
    }

    this.thread = Thread{}
    if(this.thread.create(WorkerFunction, this, this.server.engine.safeAllocator) != ThreadStatus.SUCCESS) {
        Error("Error creating worker thread\n")
        return Status.ERROR_CREATING_THREAD
    }

    return Status.OK
}

/**
    The worker function - continously runs until
    we shutdown.

    Listens for Accept submissions from the main thread
    and handles connections read/write
*/
internal func WorkerFunction(arg: *void) : i32 {
    var workerThread = arg as (*WorkerThread)

    var ring = &workerThread.ring

    var params = io_uring_params {}
    params.flags |= IORING_SETUP_SINGLE_ISSUER
    params.flags |= IORING_SETUP_COOP_TASKRUN
    params.flags |= IORING_SETUP_DEFER_TASKRUN
    params.flags |= IORING_SETUP_ATTACH_WQ
    params.wq_fd = workerThread.server.engine.ring.ring_fd

    var ioStatus = io_uring_queue_init_params(workerThread.config.ioQueueDepth, ring, &params)
    if(ioStatus != 0) {
        Error("Error initializing the io_uring queue: %d\n", ioStatus)
        return -1
    }

    Info("Started worker thread: %d ringfd: %d\n", ThreadCurrent().id(), workerThread.ring.ring_fd)

    // Signal we are ready
    pthread_barrier_wait(&workerThread.server.engine.barrier)

    // Kick off connection timeout checks
    workerThread.queueTimeoutCheck(ring)
    io_uring_submit(ring)


    var cqe: *io_uring_cqe = null;
    while(workerThread.server.engine.isRunning.get()) {
        var result = io_uring_wait_cqe(ring, &cqe);
        defer if(cqe)  {
            io_uring_cqe_seen(ring, cqe)
            cqe = null
        }

        var status = workerThread.handleCompletionRing(ring, cqe, result)
        if(status != Status.OK) {
            continue
        }

        io_uring_submit(ring)
    }

    if(ring.ring_fd > 0) {
        io_uring_queue_exit(ring)
    }

    return 0
}

func (this: *WorkerThread) queueCancelAndClose(
    ring: *io_uring,
    request: *SessionContext
): Status {

    if(request.state == SessionState.CLOSED || !request.connection.isConnected()) {
        return Status.OK;
    }

    request.state = SessionState.CLOSED

    var response = &request.response
    var connection = &request.connection

    Info("Setting connection to closed: %d\n", connection.handle())
    {
        var sqe = io_uring_get_sqe(ring)
        if(!sqe) {
            Error("Error creating SQE for socket: %d\n", connection.handle())
            goto error;
        }

        io_uring_prep_cancel(
            sqe,
            request,
            0
        )
        //io_uring_sqe_set_flags(sqe, IOSQE_CQE_SKIP_SUCCESS)

        io_uring_sqe_set_data64(
            sqe,
            RingOperation {
                .opcode = RingOpcode.CANCEL,
                .contextIndex = request.index,
            }.data
        )
    }

    request.submissions += 1
    return Status.OK

error:
    return Status.ERROR_IOURING_ERROR;
}


func (this: *WorkerThread) queueReadHttpRequest(
    ring: *io_uring,
    request: *SessionContext
): Status {

    request.state = SessionState.READ_REQUEST_LINE

    var connection = &request.connection

    Info("Reading HTTP request for socket: %d state: %s\n", connection.handle(), SessionStateAsStr(request.state))

    var sqe = io_uring_get_sqe(ring)
    if(!sqe) {
        Error("Error creating SQE for socket: %d\n", connection.handle())
        goto error;
    }

    var readBuffer = &connection.readBuffer

    // Listen for bytes from the client, store them in
    // our readBuffer, this may take multiple reads to complete
    // the full client socket payload
    io_uring_prep_read(
        sqe,
        connection.handle(),
        &readBuffer.buffer[readBuffer.length],
        readBuffer.remaining(),
        0
    )

    io_uring_sqe_set_data64(
        sqe,
        RingOperation {
            .opcode = RingOpcode.READ,
            .contextIndex = request.index,
        }.data
    )
    return Status.OK

error:
    return Status.ERROR_IOURING_ERROR;
}

func (this: *WorkerThread) queueWriteHttpResponse(
    ring: *io_uring,
    session: *SessionContext
): Status {

    session.state = SessionState.WRITTEN_HTTP_RESPONSE

    var connection = &session.connection
    var response = &session.response

    connection.bufferContents(response)

    Info("Writing Http Response (%d): \n%.*s\n",
        connection.handle(),
        connection.writeBuffer.length, connection.writeBuffer.buffer)


    var iov = iovec {
        .iov_base = connection.writeBuffer.buffer,
        .iov_len  = connection.writeBuffer.length,
    }

    var msg = msghdr {
        .msg_iov = &iov,
        .msg_iovlen = 1,
    }


    // Send the HTTP response to the client socket
    var sqe = io_uring_get_sqe(ring)
    if(!sqe) {
        Error("Error creating SQE for socket: %d\n", connection.handle())
        goto error;
    }

    var moreContents = (response.type != ResponseType.BODY)
    io_uring_prep_sendmsg(
        sqe,
        connection.handle(),
        &msg,
        moreContents ? SocketFlags.MSG_MORE : 0
    )

    io_uring_sqe_set_data64(
        sqe,
        RingOperation {
            .opcode = RingOpcode.SENDMSG,
            .contextIndex = session.index,
        }.data
    )

    // If we have more contents, let's link
    // this submission with the next one, so they are delivered
    // in proper order
    if(response.type == ResponseType.FILE) {
        sqe.flags |= IOSQE_IO_LINK
    }

    session.submissions += 1

    if(moreContents) {
        if(response.type == ResponseType.FILE) {
            session.state = SessionState.WRITTEN_HTTP_RESPONSE_MORE
            return this.queueWriteHttpFileResponse(ring, session)
        }
        else {
            assert(response.type == ResponseType.STREAM)
            session.state = SessionState.WRITING_STREAM
        }
    }

    return Status.OK

error:
    return Status.ERROR_IOURING_ERROR;
}

func (this: *WorkerThread) queueWriteHttpStreamResponse(
    ring: *io_uring,
    session: *SessionContext
): Status {

    session.state = SessionState.WRITING_STREAM

    var connection = &session.connection
    var response = &session.response
    if(!response.stream.__this) {
        Error("No stream attached to connection: %d\n", connection.handle())
        return Status.ERROR_NO_STREAM_HANDLER_FOUND
    }

    var writeBuffer = &connection.writeBuffer
    writeBuffer.clear()

    // Read the stream contents
    var numberOfBytesRead = response.stream.read(response.body.buffer, response.body.capacity)
    var moreContents = numberOfBytesRead > 0

    if(!moreContents) {
        session.state = SessionState.WRITTEN_HTTP_RESPONSE
        writeBuffer.append("0\r\n\r\n")
    }
    else {

        if(!writeBuffer.reserve(numberOfBytesRead + 16)) {
            Error(
                "Unable to handle stream of %d bytes due to out of memory for connection: %d\n",
                numberOfBytesRead,
                connection.handle()
            )
            return Status.ERROR_OUT_OF_MEMORY
        }

        writeBuffer.append("%08X\r\n", numberOfBytesRead)
        response.body.length = numberOfBytesRead
        response.body.copyTo(writeBuffer.buffer + writeBuffer.length, numberOfBytesRead, false)

        writeBuffer.length += numberOfBytesRead
        writeBuffer.appendStrn("\r\n", 2)
    }

    // Send the bytes over the TCP connection
    var iov = iovec {
        .iov_base = connection.writeBuffer.buffer,
        .iov_len  = connection.writeBuffer.length,
    }

    var msg = msghdr {
        .msg_iov = &iov,
        .msg_iovlen = 1,
    }

    var sqe = io_uring_get_sqe(ring)
    if(!sqe) {
        Error("Error creating SQE for socket: %d\n", connection.handle())
        goto error;
    }

    io_uring_prep_sendmsg(
        sqe,
        connection.handle(),
        &msg,
        moreContents ? SocketFlags.MSG_MORE : 0
    )

    io_uring_sqe_set_data64(
        sqe,
        RingOperation {
            .opcode = RingOpcode.SENDMSG,
            .contextIndex = session.index,
        }.data
    )

    session.submissions += 1

    return Status.OK

error:
    return Status.ERROR_IOURING_ERROR;
}

func (this: *WorkerThread) queueWriteHttpFileResponse(
    ring: *io_uring,
    request: *SessionContext
): Status {

    request.state = SessionState.WRITTEN_FILE

    var response = &request.response
    var connection = &request.connection

    var fileFd = response.fileHandle
    var fileSize = response.fileSize
    var socketFd = connection.handle()


    /*
        Must move the file on disk thru a pipe to client socket:
        File => Pipe => ClientSocket
    */

    if(pipe2(request.pipes, O_CLOEXEC | O_NONBLOCK) < 0) {
        Error("Error creating pipes!")
        return Status.ERROR_PIPE_ERROR
    }


    // move the file to the pipe
    {
        var sqe = io_uring_get_sqe(ring)
        if(!sqe) {
            Error("Error creating SQE for socket: %d\n", socketFd)
            goto error;
        }

        io_uring_prep_splice(
            sqe,
            response.fileHandle,
            0_i64,
            request.pipes[1],
            -1_i64,
            response.fileSize as (u32),
            0
        )
        sqe.flags |= IOSQE_IO_LINK

        io_uring_sqe_set_data64(
            sqe,
            RingOperation {
                .opcode = RingOpcode.SPLICE,
                .contextIndex = request.index,
            }.data
        )
    }

    // move the pipe to the socket
    {
        var sqe = io_uring_get_sqe(ring)
        if(!sqe) {
            Error("Error creating SQE for socket: %d\n", socketFd)
            goto error;
        }

        io_uring_prep_splice(
            sqe,
            request.pipes[0],
            -1_i64,
            connection.handle(),
            -1_i64,
            response.fileSize as (u32),
            0
        )
        sqe.flags |= IOSQE_IO_LINK

        io_uring_sqe_set_data64(
            sqe,
            RingOperation {
                .opcode = RingOpcode.SPLICE,
                .contextIndex = request.index,
            }.data
        )
    }

    // close out the file
    {
        var sqe = io_uring_get_sqe(ring)
        if(!sqe) {
            Error("Error creating SQE for socket: %d\n", socketFd)
            goto error;
        }

        io_uring_prep_close(
            sqe,
            response.fileHandle
        )

        io_uring_sqe_set_data64(
            sqe,
            RingOperation {
                .opcode = RingOpcode.CLOSE,
                .contextIndex = request.index,
            }.data
        )
    }

    request.submissions += 3
    return Status.OK

error:
    return Status.ERROR_IOURING_ERROR;
}

public func (this: *WorkerThread) sendWebSocketFrame(
    session: *SessionContext,
    frame: *Frame
) : Status {
    return this.queueWriteWebSocket(&this.ring, session, frame)
}

func (this: *WorkerThread) queueWriteWebSocket(
    ring: *io_uring,
    session: *SessionContext,
    frame: *Frame
): Status {

    session.state = SessionState.WEB_SOCKET_OPERATION

    var connection = &session.connection
    Info("Started Queued writing of web socket: %d\n", connection.handle())

    var writeBuffer = &connection.writeBuffer
    writeBuffer.clear()

    var status = frame.serialize(writeBuffer)
    if(status != Status.OK) {
        return status
    }

    // Send the bytes over the TCP connection
    var iov = iovec {
        .iov_base = writeBuffer.buffer,
        .iov_len  = writeBuffer.length,
    }

    var msg = msghdr {
        .msg_iov = &iov,
        .msg_iovlen = 1,
    }

    var sqe = io_uring_get_sqe(ring)
    if(!sqe) {
        Error("Error creating SQE for socket: %d for ring: %d\n", connection.handle(), ring.ring_fd)
        goto error;
    }

    io_uring_prep_sendmsg(
        sqe,
        connection.handle(),
        &msg,
        0
    )

    io_uring_sqe_set_data64(
        sqe,
        RingOperation {
            .opcode = RingOpcode.SENDMSG,
            .contextIndex = session.index,
        }.data
    )

    session.submissions += 1
    io_uring_submit(ring)

    return Status.OK;

error:
    return Status.ERROR_IOURING_ERROR;
}

func (this: *WorkerThread) queueReadWebSocket(
    ring: *io_uring,
    session: *SessionContext
): Status {

    session.state = SessionState.WEB_SOCKET_OPERATION
    var connection = &session.connection

    var sqe = io_uring_get_sqe(ring)
    if(!sqe) {
        Error("Error creating SQE for socket: %d\n", connection.handle())
        goto error;
    }

    var readBuffer = &connection.readBuffer

    // Listen for bytes from the client, store them in
    // our readBuffer, this may take multiple reads to complete
    // the full client socket payload
    io_uring_prep_read(
        sqe,
        connection.handle(),
        &readBuffer.buffer[readBuffer.length],
        readBuffer.remaining(),
        0
    )

    io_uring_sqe_set_data64(
        sqe,
        RingOperation {
            .opcode = RingOpcode.READ,
            .contextIndex = session.index,
        }.data
    )

    return Status.OK

error:
    return Status.ERROR_IOURING_ERROR;
}



func (this: *WorkerThread) handleWebSocketFrame(
    ring: *io_uring,
    session: *SessionContext,
    bytesRead: i32
): Status {

    var requestAllocator = &session.requestAllocator.allocator
    var connection = &session.connection
    var readBuffer = &connection.readBuffer

    readBuffer.length += bytesRead

    var frame = Frame{}
    var status = frame.parseHeader(readBuffer)
    if(status != ParseStatus.OK) {
        return Status.ERROR_WEB_SOCKET_FRAME
    }

    if(this.config.maxHttpBodySizeInBytes > 0 &&
       frame.payloadLength > this.config.maxHttpBodySizeInBytes
    ) {
        Error(
            "Web socket frame length of %lu bytes is greater than configured max of %lu bytes\n",
            frame.payloadLength,
            this.config.maxHttpBodySizeInBytes
        )
        return Status.ERROR_INVALID_BODY_EXCEEDED_LIMIT
    }

    status = frame.parsePayload(readBuffer)
    if(status != Status.OK) {
        if(status == Status.ERROR_WEB_SOCKET_FRAME_LENGTH) {

            // grow the buffer for the next read
            if((readBuffer.capacity - frame.offset) < frame.payloadLength) {
                var neededSpace = frame.payloadLength - readBuffer.capacity
                readBuffer.reserve(
                    readBuffer.capacity + neededSpace as (i32)
                )
                Error("TODO: Grow buffer!\n")
                exit(1) // TODO
                return Status.ERROR_OUT_OF_MEMORY
            }

            // Partial read, need to wait for more bytes
            return Status.PARTIAL_WEB_SOCKET_DISPATCHING_READ
        }
        return Status.ERROR_WEB_SOCKET_FRAME
    }

    defer readBuffer.clear()

    if(session.socketHandler.callback) {
        if(!session.socketHandler.callback(&session.socketSession, frame)) {
            return Status.ERROR_WEB_SOCKET_HANDLE_FRAME_ERROR
        }
    }

    if(frame.opcode == Opcode.CLOSE) {
        return Status.WEB_SOCKET_CLOSED
    }

    return Status.OK
}

func (this: *WorkerThread) handlePartialHttpRequest(
    ring: *io_uring,
    request: *SessionContext,
    bytesRead: i32
): Status {

    var connection = &request.connection
    var readBuffer = &connection.readBuffer

    readBuffer.length += bytesRead

    var buffer = readBuffer.asString()
    if(request.requestLineIndex < 1) {
        request.requestLineIndex = buffer.endIndexOf($"\r\n")
        if(request.requestLineIndex < 0) {
            if(readBuffer.remaining() < this.config.maxHttpRequestLineSizeInBytes) {
                readBuffer.reserve(readBuffer.capacity + this.config.maxHttpRequestLineSizeInBytes as (i32))
            }

            Info("RequestLine not fully read, dispatching another io-read for connection: %d\n", connection.handle())
            return Status.PARTIAL_REQUEST_DISPATCHING_READ
        }

        if(request.requestLineIndex > this.config.maxHttpRequestLineSizeInBytes) {
            Error("RequestLine of size '%d' exceeded max request limit of '%d' for connection: %d\n",
                request.requestLineIndex,
                this.config.maxHttpRequestLineSizeInBytes,
                connection.handle()
            )
            return Status.ERROR_INVALID_REQUEST_PATH_EXCEEDED_LIMIT
        }
    }


    if(request.headerIndex < 1) {
        request.headerIndex = buffer.endIndexOf($"\r\n\r\n")
        if(request.headerIndex < 0) {
            if(readBuffer.remaining() < this.config.maxHttpHeaderSizeInBytes) {
                readBuffer.reserve(readBuffer.capacity + this.config.maxHttpHeaderSizeInBytes as (i32))
            }

            Info("Headers not fully read, dispatching another io-read for connection: %d\n", connection.handle())
            return Status.PARTIAL_REQUEST_DISPATCHING_READ
        }
        var headerSize = request.headerIndex - request.requestLineIndex
        Info("Request Line: %d HeaderIndex: %d Size: %d\n", request.requestLineIndex, request.headerIndex, headerSize)
        if(headerSize > this.config.maxHttpHeaderSizeInBytes) {
            Error("Headers of size '%d' exceeded max request limit of '%d' for connection: %d\n",
                request.headerIndex,
                this.config.maxHttpHeaderSizeInBytes,
                connection.handle()
            )
            return Status.ERROR_INVALID_HEADER_EXCEEDED_LIMIT
        }

        request.bodyIndex = request.headerIndex
    }

    // we've read the http header part, now
    // let's ensure we've read the entire body
    var parser = HttpParser{}
    parser.init(&request.requestAllocator.allocator)

    var input = String {
        .buffer = readBuffer.buffer,
        .length = request.headerIndex
    }

    var httpRequest = &request.request
    var ok = parser.parse(input, httpRequest)
    if(ok != ParseStatus.OK) {
        Error("Error parsing http request: %s\n", ParseStatusAsStr(ok))
        return Status.ERROR_PARSING_HTTP_REQUEST
    }

    if(httpRequest.flags & HttpFlags.CHUNKED_ENCODING) {
        var status = parser.parseChunk(readBuffer.asString().substring(request.headerIndex), httpRequest)
        if(status == ParseStatus.CHUNK_INCOMPLETE) {
            Info("Chunked Body not fully read, dispatching another io-read for connection: %d\n", connection.handle())
            return Status.PARTIAL_REQUEST_DISPATCHING_READ
        }

        if(status != ParseStatus.OK) {
            Error("Error parsing chunk encoding for http request: %s\n", ParseStatusAsStr(status))
            return Status.ERROR_PARSING_HTTP_REQUEST
        }
    }
    else if(httpRequest.flags & HttpFlags.CONTENT_LENGTH_PROVIDED) {
        var bodyLength = httpRequest.bodyLength
        if(this.config.maxHttpBodySizeInBytes > 0 && bodyLength > this.config.maxHttpBodySizeInBytes) {
            Error("Body of size '%d' exceeded max request limit of '%d' for connection: %d\n",
                bodyLength,
                this.config.maxHttpBodySizeInBytes,
                connection.handle()
            )
            return Status.ERROR_INVALID_BODY_EXCEEDED_LIMIT
        }

        if(readBuffer.length - request.headerIndex < bodyLength) {
            if(readBuffer.remaining() < 1 * MiB) {
                readBuffer.reserve(readBuffer.capacity + 1 * MiB as (i32))
            }

            Info("Body not fully read, dispatching another io-read for connection: %d\n", connection.handle())
            return Status.PARTIAL_REQUEST_DISPATCHING_READ
        }
    }
    else  {
        var body = readBuffer.asString().substring(request.headerIndex)
        if(!body.empty()) {
            // No chunked encoding and no content-length header, return back invalid request
            return Status.ERROR_UNKNOWN_BODY_LENGTH
        }
    }

    // we are ready to handle the full request
    return Status.OK
}

func (this: *WorkerThread) handleHttpRequest(
    ring: *io_uring,
    request: *SessionContext
): Status {

    var requestAllocator = &request.requestAllocator.allocator
    var connection = &request.connection

    var buffer = &connection.readBuffer
    Info("Begin handling HTTP Request for socket: %d\n%.*s\n", connection.handle(), buffer.length, buffer.buffer)

    var parser = HttpParser{}
    parser.init(requestAllocator)

    var input = StringInit(buffer.buffer, buffer.length).substring(request.bodyIndex)

    var httpRequest = &request.request;

    // Since chunked encoding is handled by reading the full
    // payload from the client, if this a chunked encoding from
    // the client, don't use the raw readBuffer, instead use the
    // chunkData buffer that contains the decoded data
    if(httpRequest.flags & HttpFlags.CHUNKED_ENCODING) {
        input = httpRequest.body.chunkData.asString()
    }

    var ok = parser.parseBody(input, httpRequest)
    if(ok != ParseStatus.OK) {
        Error("Error parsing http request: %s\n", ParseStatusAsStr(ok))
        return Status.ERROR_PARSING_HTTP_REQUEST
    }

    connection.disableKeepAlive = httpRequest.flags & HttpFlags.DISABLE_KEEP_ALIVE

    if(httpRequest.method == HttpMethod.GET) {
        // the client is requesting a file
        if(httpRequest.path.startsWith(this.server.config.fileServerPath.toString())) {
            return this.handleFileRequest(request, ring, httpRequest)
        }
    }

    var requestContext = RequestHandlerContext {
        .allocator = requestAllocator,
        .request = httpRequest,
        .response = &request.response,
        .userData = null,
        .match = null,
        .sessionIndex = request.index
    }

    var requestMatch: RouteMatch;
    if(!this.server.router.match(httpRequest.method, httpRequest.path, &requestMatch)) {
        this.server404(&requestContext, Status.ERROR_NO_ROUTE_FOUND)
    }
    else {
        var handler = requestMatch.handler

        requestContext.userData = handler.userData
        requestContext.match = &requestMatch

        switch(handler.type) {
            case RequestHandlerType.HTTP_REQUEST: {
                if(handler.controller.callback(&requestContext) != 1) {
                    this.serverError(&requestContext, Status.ERROR_CONTROLLER_CALLBACK_ERROR)
                }
                break
            }
            case RequestHandlerType.WEB_SOCKET: {
                if(httpRequest.method != HttpMethod.GET) {
                    // TODO: Handle incorrect request type
                    this.serverError(&requestContext, Status.ERROR_CONTROLLER_CALLBACK_ERROR)
                    break
                }

                // the client is requesting an upgrade to a different
                // protocol
                if(httpRequest.flags & HttpFlags.UPGRADE_REQUEST) {
                    if(!(httpRequest.flags & HttpFlags.WEB_SOCKET_PROTOCOL)) {
                        return this.sendBadRequest(request, Status.ERROR_UNSUPPORTED_UPGRADE_PROTOCOL, ring)
                    }

                    return this.handleWebSocketUpgrade(
                        request,
                        ring,
                        httpRequest,
                        &requestContext
                    )
                }

                break
            }
            default: {
                assert(false)
            }
        }
    }

    return this.queueWriteHttpResponse(ring, request)
}

import "std/crypto/sha1"
import "std/encoding/base64"

func (this: *WorkerThread) handleWebSocketUpgrade(
    context: *SessionContext,
    ring: *io_uring,
    httpRequest: *HttpRequest,
    requestContext: *RequestHandlerContext
): Status {

    var secKey = httpRequest.getHeaderValue($"Sec-WebSocket-Key")

    if (secKey.empty()) {
        return Status.ERROR_WEB_SOCKET_SECURITY_KEY
    }

    var keyBuffer = [128]char;
    var keyString = StringBufferInit(keyBuffer, 128)
    keyString.append("%.*s%s", secKey.length, secKey.buffer, WEB_SOCKET_MAGIC)

    var hashResult:[SHA1_BLOCK_SIZE]u8;
    var ctx: sha1_ctx;

    sha1_init(&ctx)
    sha1_update(&ctx, keyString.cStr(), keyString.length)
    sha1_final(&ctx, hashResult)

    var keyAccept = context.requestAllocator.alloc(sizeof(:u8) * 64) as (*u8)
    var bytesEncoded = base64_encode(hashResult, keyAccept, SHA1_BLOCK_SIZE, 0)

    var response = &context.response
    response.status = 101
    response.type = ResponseType.BODY
    response.addHeaderStr("Upgrade", "websocket")
    response.addHeaderStr("Connection", "Upgrade")
    response.addHeader(
        StringInit("Sec-WebSocket-Accept"),
        String{.buffer = keyAccept as (*const char), .length = bytesEncoded as (i32)}
    )

    context.socketSession.worker = this
    context.socketSession.userData = requestContext.userData
    context.socketSession.allocator = requestContext.allocator

    var requestMatch = requestContext.match
    assert(requestMatch.handler.type == RequestHandlerType.WEB_SOCKET)
    context.socketHandler = requestMatch.handler.webSocket
    context.isWebSocket = true

    var connection = &context.connection
    var readBuffer = &connection.readBuffer
    readBuffer.clear()

    this.queueWriteHttpResponse(ring, context)
    context.state = SessionState.WEB_SOCKET_UPGRADED

    return Status.OK
}

func (this: *WorkerThread) handleFileRequest(
    session: *SessionContext,
    ring: *io_uring,
    httpRequest: *HttpRequest
): Status {

    // TODO: Cache File contents
    var file: File;
    var fileStatus = OpenFile(this.config.fileServerPath, httpRequest.path, &file)
    if(fileStatus != Status.OK) {
        return fileStatus
    }

    session.file = file.handle()

    var response = &session.response;
    response.status = 200
    response.type = ResponseType.FILE
    response.fileHandle = file.handle()
    response.fileSize = file.length()

    // TODO add mime type info..
    return this.queueWriteHttpResponse(ring, session)
}


func (this: *WorkerThread) sendServerError(
    session: *SessionContext,
    status: Status,
    ring: *io_uring
): Status {
    var httpRequest = HttpRequest{}
    var requestContext = RequestHandlerContext {
        .allocator = &session.requestAllocator.allocator,
        .request = &httpRequest,
        .response = &session.response,
        .userData = null,
        .match = null
    }

    this.serverError(requestContext, status)
    return this.queueWriteHttpResponse(ring, session)
}

func (this: *WorkerThread) serverError(
    requestContext: *RequestHandlerContext,
    status: Status
) {
    var request = requestContext.request
    var response = requestContext.response

    Error("Internal Error handling request: %s %.*s\n",
        HttpMethodAsStr(request.method),
        request.path.length, request.path.buffer
    )

    response.status = 500

    if (this.server.errorHandler.__this) {
        this.server.errorHandler.handle(
            requestContext,
            status
        )
    }
    else {
        // TODO add mime type info..
        response.type = ResponseType.BODY
        response.body.append("Internal Error handling the request.")
    }
}

func (this: *WorkerThread) server404(
    requestContext: *RequestHandlerContext,
    status: Status
) {
    var request = requestContext.request
    var response = requestContext.response

    Error("Could not find match for request: %s %.*s\n",
        HttpMethodAsStr(request.method),
        request.path.length, request.path.buffer
    )

    response.status = 404

    if (this.server.notFoundHandler.__this) {
        this.server.notFoundHandler.handle(
            requestContext,
            status
        )
    }
    else {
        // TODO add mime type info..
        response.type = ResponseType.BODY
        response.body.append("No route bound.")
    }
}

func (this: *WorkerThread) sendBadRequest(
    context: *SessionContext,
    status: Status,
    ring: *io_uring
): Status {
    var httpRequest = HttpRequest{}
    var requestContext = RequestHandlerContext {
        .allocator = &context.requestAllocator.allocator,
        .request = &httpRequest,
        .response = &context.response,
        .userData = null,
        .match = null
    }

    var request = requestContext.request
    var response = requestContext.response

    Error("Bad request (%s) for request: %s %.*s\n",
        StatusAsStr(status),
        HttpMethodAsStr(request.method),
        request.path.length, request.path.buffer
    )

    response.status = 400

    // TODO add mime type info..
    response.type = ResponseType.BODY
    switch(status) {
        case Status.ERROR_INVALID_REQUEST_PATH_EXCEEDED_LIMIT:
            response.body.append(
                "Request exceeded the max request limit of %d bytes for request line\n",
                this.config.maxHttpRequestLineSizeInBytes
            )
            break
        case Status.ERROR_INVALID_HEADER_EXCEEDED_LIMIT:
            response.body.append(
                "Request exceeded the max request limit of %d bytes for headers\n",
                this.config.maxHttpHeaderSizeInBytes
            )
            break
        case Status.ERROR_INVALID_BODY_EXCEEDED_LIMIT:
            response.status = 413
            response.body.append(
                "Request exceeded the max request limit of %d bytes for request body\n",
                this.config.maxHttpBodySizeInBytes
            )
            break
        case Status.ERROR_UNKNOWN_BODY_LENGTH: {
            response.body.append(
                "Missing Content-Length or Transfer-Encoding\n"
            )
            break
        }
        case Status.ERROR_UNSUPPORTED_UPGRADE_PROTOCOL:
            response.status = 426
            response.body.append(
                "The requested protocol upgrade is not supported by the server\n"
            )
            break
        default: {
            response.body.append(
                "Bad request\n",
                this.config.maxHttpBodySizeInBytes
            )
            break
        }
    }

    return this.queueWriteHttpResponse(ring, context)
}

func (this: *WorkerThread) handleAccept(clientSocket: i32) : *SessionContext {
    var index = this.sessions.alloc()
    if(index < 0) {
        Warn("SessionContext Pool has been exhausted, delaying accept request\n")
        return null
    }

    var session = this.sessions.get(index)
    assert(session != null)

    session.begin(clientSocket)
    return session
}

func (this: *WorkerThread) handleCompletionRing(
    ring: *io_uring,
    cqe: *io_uring_cqe,
    result: i32
): Status {

    if(!cqe) {
        Error("Error reading completion queue: %d\n", result)
        assert(false)

        return Status.ERROR_IO_ERROR;
    }

    // Determine if this is a timeout or a socket error
    if(cqe.res < 0) {
        // no attached data, this should be a timeout check
        var operation = RingOperation {
            .data = io_uring_cqe_get_data64(cqe)
        }

        if(operation.opcode == RingOpcode.TIMEOUT) {
            return this.checkTimeouts(ring)
        }

        var session = this.sessions.get(operation.contextIndex)
        assert(session != null)

        switch(cqe.res) {
            case -ENOENT:
            case -EINVAL:
            case -EALREADY: {
                if (!session.connection.isConnected()) {
                    break
                }

                Info("Unable to cancel operations for socket: %d due to already in progress or not found\n",
                    session.connection.handle()
                )

                session.finish(.forceClose = true)
                break
            }
            case -ECANCELED: {
                Info("Canceled request queue entries for socket: %d\n",
                    session.connection.handle()
                )
                break
            }
            default: {
                // otherwise we are experiencing a socket error
                Error("Error with socket (%d) completion result: %d (%s)\n",
                    session.connection.handle(),
                    cqe.res,
                    strerror(-cqe.res)
                )

                // Force close the connection
                Error("Force closing connection: %d due to error\n", session.connection.handle())
                if (!session.connection.isConnected()) {
                    break
                }
                session.finish(.forceClose = true)
                break
            }
        }

        return Status.OK
    }

    var operation = RingOperation {
        .data = io_uring_cqe_get_data64(cqe)
    }

    var session: *SessionContext = null

    // if we are receiving a msg from the accept ring,
    // handle the new connection
    if(operation.opcode == RingOpcode.MSG_RING) {
        session = this.handleAccept(operation.contextIndex)
    }
    else {
        session = this.sessions.get(operation.contextIndex)
    }

    assert(session != null)

    session.lastRequestTime = SystemTimeMSec()
    var connection = &session.connection

    // this connection has been terminated
    if(!connection.isConnected()) {
        return Status.OK
    }

    switch(session.state) {
        // Server just accepted a client connection
        case SessionState.CONNECTED: {
            Info("Reading HTTP request for socket: %d\n", connection.handle())
            // queue up delegation of handling the http request
            return this.queueReadHttpRequest(ring, session)
        }
        // The connection was established, and we've read
        // the client socket contents for the HTTP request line
        case SessionState.READ_REQUEST_LINE: {
            var bytesRead = cqe.res
            Info("READ_REQUEST_LINE: %d for socket: %d subs: %d\n", bytesRead, connection.handle(), session.submissions)

            // The client has gracefully closed their connection
            if(bytesRead == 0) {
                Info("Client Closed socket: %d\n", connection.handle())
                return this.queueCancelAndClose(ring, session)
            }

            var status = this.handlePartialHttpRequest(
                ring,
                session,
                bytesRead
            )

            if(status == Status.PARTIAL_REQUEST_DISPATCHING_READ) {
                return this.queueReadHttpRequest(ring, session)
            }

            if(status != Status.OK) {
                switch(status) {
                    case Status.ERROR_UNKNOWN_BODY_LENGTH:
                    case Status.ERROR_INVALID_REQUEST_PATH_EXCEEDED_LIMIT:
                    case Status.ERROR_INVALID_HEADER_EXCEEDED_LIMIT:
                    case Status.ERROR_INVALID_BODY_EXCEEDED_LIMIT: {
                        return this.sendBadRequest(session, status, ring)
                    }
                    default: {
                        return this.sendServerError(session, status, ring)
                    }
                }
                return status
            }

            // queue up delegation of handling the http response
            status = this.handleHttpRequest(
                ring,
                session
            )

            if(status != Status.OK) {
                Error("HTTP Request Bad Status %s with index: %d\n", StatusAsStr(status), session.index)
                return this.sendServerError(session, status, ring)
            }
            break
        }
        case SessionState.WEB_SOCKET_UPGRADED: {
            Info("WebSocket upgraded for socket: %d\n", connection.handle())
            return this.queueReadWebSocket(ring, session)
        }
        case SessionState.WEB_SOCKET_OPERATION: {
            switch(operation.opcode) {
                case RingOpcode.SENDMSG: {
                    Info("WebSocket write completed for socket: %d\n",
                        connection.handle()
                    )
                    session.submissions -= 1

                    // we sent out a close operation, clean up
                    if(!session.isWebSocket) {
                        return this.queueCancelAndClose(ring, session)
                    }
                    break
                }
                case RingOpcode.READ: {
                    var bytesRead = cqe.res
                    Info("WebSocket read completed for socket: %d bytes read: %d\n",
                        connection.handle(),
                        bytesRead
                    )

                    // client closed the socket
                    if(bytesRead == 0) {
                        Info("Client Closed socket: %d\n", connection.handle())
                        return this.queueCancelAndClose(ring, session)
                    }

                    var status = this.handleWebSocketFrame(ring, session, bytesRead)
                    if(status == Status.WEB_SOCKET_CLOSED) {
                        Info("Client Closed socket: %d\n", connection.handle())
                        return this.queueCancelAndClose(ring, session)
                    }
                    else if(status != Status.OK) {
                        Error(
                            "Error handling websocket frame for socket: %d: %s\n",
                            connection.handle(),
                            StatusAsStr(status)
                        )
                        // TODO
                        assert(false)
                        return status
                    }

                    return this.queueReadWebSocket(ring, session)
                }
                default: {
                    Error("Unsupported web socket operation: %s\n", RingOpcodeAsStr(operation.opcode))
                    break
                }
            }
            break
        }
        case SessionState.WRITING_STREAM: {
            session.submissions -= 1

            return this.queueWriteHttpStreamResponse(ring, session)
        }
        // The connection request was parsed, we have dispatched
        // an http response to the client socket
        case SessionState.WRITTEN_HTTP_RESPONSE:
        case SessionState.WRITTEN_HTTP_RESPONSE_MORE:
        case SessionState.WRITTEN_FILE: {
            session.submissions -= 1
            Info("%s for socket: %d subs: %d index: %d\n",
                SessionStateAsStr(session.state),
                connection.handle(),
                session.submissions,
                session.index
            )

            if(session.submissions <= 0) {
                Info("Preparing connection for another HTTP request for socket: %d\n", connection.handle())
                session.begin(connection.handle()) // ready to begin another HTTP request cycle

                // listen for close socket from client
                return this.queueReadHttpRequest(ring, session)
            }
            break
        }
        case SessionState.CLOSED: {
            Info("Request is forcing closed for connection: %d\n", connection.handle())
            if (!connection.isConnected()) {
                break
            }

            session.finish(.forceClose = true)
            break
        }
        case SessionState.UNKNOWN: {
            Info("Request caught in unknown state for connection: %d\n", connection.handle())
            break
        }
        default: {
            Panic("Unknown state: %d\n", session.state)
            assert(false)
            break;
        }
    }

    return Status.OK
}

func (this: *WorkerThread) queueTimeoutCheck(ring: *io_uring): Status {
    var sqe = io_uring_get_sqe(ring)
    if(!sqe) {
        Error("Error creating SQE for timeout check\n")
        goto error;
    }

    var ts: __kernel_timespec;
    ts.tv_sec = this.config.timeoutCheckMSec / 1_000;
    ts.tv_nsec = (this.config.timeoutCheckMSec % 1_000) * 1_000_000;

    io_uring_prep_timeout(
        sqe,
        &ts,
        0,
        0 // IORING_TIMEOUT_ETIME_SUCCESS (not supported on all uring instances yet)
    )

    io_uring_sqe_set_data64(
        sqe,
        RingOperation {
            .opcode = RingOpcode.TIMEOUT,
            .contextIndex = -1,
        }.data
    )

    return Status.OK;

error:
    return Status.ERROR_IOURING_ERROR;
}

func (this: *WorkerThread) checkTimeouts(ring: *io_uring): Status {
    var timeout = this.config.keepAliveTimeoutInSec
    const currentTime = SystemTimeMSec()

    for(var i = 0; i < this.sessions.pool.size(); i+=1) {
        var context = this.sessions.pool.getPtr(i)
        if(context.inUse && context.connection.isConnected()) {
            if(context.isWebSocket) {
                timeout = 90 // TODO: Make this configurable via settings
            }

            if(context.lastRequestTime + timeout < currentTime) {
                Info("HTTP connection timedout socket: %d (index: %d) -> %f vs. %f\n",
                    context.connection.handle(),
                    context.index,
                    context.lastRequestTime + timeout,
                    currentTime
                )

                this.queueCancelAndClose(ring, context)
            }
        }
    }

    return this.queueTimeoutCheck(ring)
}